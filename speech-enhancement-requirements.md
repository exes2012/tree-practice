# Техническое задание: Улучшение речевого тренажера и рецензия на логику работы практики

## Общее описание системы

У нас есть Angular приложение для практик медитации с инновационной архитектурой на основе **generator функций**. Каждая практика определяется как async generator function, что позволяет создавать как линейные последовательности шагов, так и сложные логические структуры с циклами, условными переходами и динамическим поведением.

## Архитектурный подход к практикам

### 1. Generator-based архитектура

Основа системы - использование JavaScript generator функций для определения практик:

```typescript
export async function* myPractice(context: PracticeContext): AsyncIterableIterator<PracticeStep> {
  yield step('step1', 'Шаг 1', 'Первая инструкция');
  const userInput = yield input('step2', 'Шаг 2', 'Введите данные', 'fieldName');
  // Логика, циклы, условия...
  yield rating('final', 'Оценка', 'Оцените практику', true);
}
```

**Преимущества этого подхода:**
- **Императивный код**: можно использовать циклы, условия, переменные
- **Контекстность**: доступ к результатам предыдущих шагов через `context` и переменные
- **Динамическое поведение**: шаги могут генерироваться условно
- **Композиция**: можно комбинировать блоки через `yield*`

### 2. Типы практик в системе

#### А) Простые линейные практики
```typescript
export const simpleManPractice = createLinearPractice([
  step('feeling', 'Ощущение', 'Почувствуй пространство, себя, свое тело.'),
  input('problem', 'Проблема', 'С чем работаем?', 'userProblem', 'textarea'),
  repeat('self-cancel', 'Самоотмена', 'Инструкция...', 'Мне не важно...'),
  rating('final-rating', 'Оценка', 'Оцените от 1 до 10', true)
]);
```

#### Б) Композитные практики с блоками
```typescript
export async function* composedPractice(context: PracticeContext): AsyncIterableIterator<PracticeStep> {
  // Базовые шаги
  yield* manBlocks.feeling();
  yield* manBlocks.defineProblem();
  
  // Кастомная логика
  const problem = context.get('userProblem');
  if (problem.includes('цель')) {
    yield* goalBlocks.formulateGoal();
  }
  
  // Общие блоки
  yield* manBlocks.selfCancellation();
  yield* manBlocks.finalRating();
}
```

#### В) Сложные практики с циклами и условиями
```typescript
export async function* alignmentPractice(context: PracticeContext): AsyncIterableIterator<PracticeStep> {
  // Базовые шаги
  yield step('feeling', 'Ощущение', 'Почувствуй пространство...');
  yield input('formulate-goal', 'Цель', 'Какую цель проработать?', 'practiceFormulation');
  
  // ГЛАВНЫЙ ЦИКЛ - до получения оценки 10
  let attempts = 0;
  while (attempts < 5) {
    attempts++;
    
    const alignmentRating: number = yield input(
      `alignment-rating-${attempts}`,
      'Сравнение ощущений',
      'Сравните ощущение цели с благодарностью к Творцу (1-10)',
      'alignmentRating',
      'number'
    );
    
    // Условная логика
    if (alignmentRating === 10) {
      // Спрашиваем об обновлении
      yield radio('goal-update-question', 'Обновление цели', 
        'Обновить формулировку цели?', 'shouldUpdateGoal',
        [
          { value: true, label: 'Да, обновить' },
          { value: false, label: 'Нет, оставить' }
        ]);
      break; // Выходим из цикла
    }
    
    // Цикл рефайнмента - переформулировка цели
    const rephrasedGoal = yield input(
      `rephrase-goal-${attempts}`,
      'Переформулировка',
      'Как переформулировать цель для оценки 10/10?',
      'rephrasedGoal',
      'textarea'
    );
    
    // Динамическое обновление контекста
    context.set('practiceFormulation', rephrasedGoal);
    
    // Новое видение
    yield input(`new-vision-${attempts}`, 'Новое видение', 
      'Как выглядит достижение новой формулировки?', 'visionAfterAchievingGoal');
  }
  
  // Финальная оценка
  const finalRating = yield rating('final-rating', 'Оценка всей проработки', 
    'Оцените от 1 до 10', true);
  
  // Возвращаем результат
  return {
    finalFormulation: context.get('practiceFormulation'),
    attempts,
    finalRating
  };
}
```

### 3. Переиспользуемые блоки

Система имеет библиотеку готовых блоков в `practice-blocks.ts`:

#### Блоки МАН практик:
```typescript
manBlocks.feeling()           // Базовое ощущение
manBlocks.defineProblem()     // Определение проблемы  
manBlocks.localizeProblem()   // Локализация в теле
manBlocks.selfCancellation()  // Самоотмена с повторяемой фразой
manBlocks.findOthers()        // Поиск других душ (с повтором)
manBlocks.conductLight()      // Проводник света (с повтором)
manBlocks.uniteAll()          // Соединение всех (с повтором)
manBlocks.gratitude()         // Благодарность
manBlocks.finalRating()       // Оценка
```

#### Блоки для работы с целями:
```typescript
goalBlocks.formulateGoal()           // Формулировка цели
goalBlocks.visionAfterGoal()         // Видение достигнутой цели
goalBlocks.selfCancellationForGoal() // Самоотмена для цели
goalBlocks.findOthersWithGoal()      // Поиск других с такой целью
```

### 4. Типы шагов и их особенности

#### simple - простая инструкция
```typescript
step('feeling', 'Ощущение', 'Почувствуй пространство, себя, свое тело.')
```

#### input - ввод данных пользователем  
```typescript
input('problem', 'Проблема', 'С чем работаем?', 'fieldName', 'textarea', 'Плейсхолдер...')
// Поддерживает: text, textarea, number, radio
```

#### repeat - шаг с медитативными повторами
```typescript
repeat('self-cancel', 'Самоотмена', 'Инструкция...', 'Повторяемая фраза для медитации')
// Фраза автоматически повторяется каждые 5 секунд голосом
```

#### rating - оценочный шаг
```typescript
rating('final', 'Оценка', 'Оцените от 1 до 10', true) // true = финальный
```

### 5. Контекстная система

**PracticeContext** - хранит состояние практики:
- Пользовательские вводы через `context.set()` / `context.get()`
- Плейсхолдеры в тексте: `"Проблема {{userProblem}} решается"`  
- История шагов для возможности возврата
- Связь с внешними данными (цели, профиль пользователя)

### 6. Примеры реальных повторяемых фраз в практиках

В системе активно используются медитативные фразы с повторами. Вот реальные примеры из практик:

#### Самоотмена:
```
"Мне не важно, решится ли "стресс на работе", или нет. Мне нужна только связь с Творцом. И я здесь только для того, чтобы с ним соединиться через эту проблему."
```

#### Поиск других душ:
```
"Все души, у которых есть такая же проблема, отпечатаны во мне. Мы связаны в одну общую систему. Их страдание — выражение желания, в котором пока ещё действует эгоистический расчёт."
```

#### Проводник света:
```
"Творец, исправь их намерение из получения в отдачу, приблизь их к себе и наполни их нехватки благом и наслаждением."
```

#### Свет вместо тьмы:
```
"Творец, исправь их намерение из получения в отдачу, приблизь их к себе и наполни их нехватки благом и наслаждением."
```

#### Соединение всех участников:
```
"Всё, что существует внутри этой системы, включая эту проблему — и есть Творец."
```

#### Исправление намерения:
```
"Творец, исправь мое намерение, чтобы оно было ради связи, ради отдачи, ради Тебя."
```

**Особенности этих фраз:**
- Содержат несколько предложений (2-4 предложения)
- Имеют сложную структуру с придаточными предложениями
- Могут включать плейсхолдеры с пользовательскими данными
- Предназначены для медитативного повторения с паузами
- Сейчас произносятся как один непрерывный поток без пауз между предложениями

### 7. Навигация между шагами

**Переходы вперед**: Работают через `practiceEngine.nextStep(userInput)`
**Переходы назад**: **ПРОБЛЕМА** - метод `goBack()` имеет заглушку 

Текущая реализация возврата:
```typescript
async goBack(): Promise<void> {
  // Упрощенная реализация
  console.warn('GoBack is simplified - consider redesigning for full backward navigation');
}
```

**Особенности навигации в generator архитектуре:**
- Generator можно только продвигать вперед через `iterator.next()`
- Для возврата назад нужно либо сохранять состояния, либо пересоздавать iterator
- У нас есть `stepHistory[]` но нет механизма восстановления состояния

## Текущая архитектура

### PracticeEngineV2Service
- Управляет логикой практик через generator функции
- Эмитит `currentStep` через BehaviorSubject
- Поддерживает переходы вперед/назад по шагам
- Хранит контекст и историю шагов

### PracticeRunnerComponent
- Подписывается на изменения шагов через RxJS операторы (distinctUntilChanged, debounceTime)
- Управляет UI состоянием и голосовым сопровождением
- Использует `handleStepChange()` для централизованной обработки смены шагов
- Имеет защиту от дублированных вызовов через флаги `isSpeaking`, `currentStepId`

### SpeechService (недавно переработан)
- Использует Web Speech Synthesis API
- Имеет очередь речи для предотвращения конфликтов
- Поддерживает два типа речи: основную (инструкции) и повторы (медитативные фразы)
- Автоматически управляет последовательностью: основная речь → пауза → повторы
- Обрабатывает ошибки interrupted корректно

## Типы шагов

```typescript
interface PracticeStep {
  id: string;
  title: string;
  instruction: string; // Основная инструкция для озвучивания
  type: 'simple' | 'input' | 'rating' | 'repeat';
  
  // Для шагов с повторами
  repeatablePhrase?: string; // Фраза для медитативного повтора
  showToggleRepetition?: boolean; // Показывать ли кнопку управления повтором
  
  // Для шагов с вводом данных
  inputConfig?: {
    field: string;
    type: 'text' | 'textarea' | 'number' | 'radio';
    placeholder?: string;
    options?: Array<{value: any, label: string}>;
  };
  
  // Для рейтинговых шагов
  ratingConfig?: {
    min: number;
    max: number;
  };
  
  // Навигация
  buttonText?: string;
  isFinalStep?: boolean;
}
```

## Текущий флоу работы

1. **Смена шага**: `PracticeEngine` эмитит новый `currentStep`
2. **Обработка**: `handleStepChange()` проверяет изменение по `step.id`
3. **Остановка речи**: `stopCurrentSpeech()` прерывает предыдущую речь
4. **Подготовка UI**: `prepareStepUI()` настраивает состояние интерфейса
5. **Озвучивание**: `speakCurrentStep()` проговаривает инструкцию
6. **Автоповторы**: Если у шага есть `repeatablePhrase` - запускаются повторы каждые 5 секунд

## Проблемы для решения

### 1. Кнопка "Назад" не работает
**Проблема**: Метод `goBack()` в `PracticeEngineV2Service` имеет упрощенную реализацию и не может корректно вернуться к предыдущему шагу в generator функции.

**Текущий код:**
```typescript
async goBack(): Promise<void> {
  if (this.stepHistory.length === 0) return;
  
  // Удаляем последний шаг из истории
  const lastStep = this.stepHistory.pop();
  
  // Примечание: это упрощенная реализация
  // В реальности нужно будет пересоздавать iterator или использовать другой подход
  console.warn('GoBack is simplified - consider redesigning for full backward navigation');
}
```

**Нужно**: Полноценная реализация возврата назад по шагам практики.

### 2. Настраиваемые паузы между предложениями в повторах

**Задача**: Добавить возможность контролировать длительность пауз между предложениями внутри `repeatablePhrase`.

**Примеры фраз для повтора:**
- "Я принимаю себя. Я люблю себя. Я прощаю себя."
- "Дышу спокойно. Расслабляюсь. Отпускаю напряжение."
- "Здесь и сейчас. В этот момент. Я в безопасности."

**Требования:**
1. Парсить `repeatablePhrase` на предложения (по точкам, восклицательным знакам, вопросительным знакам)
2. Добавлять настраиваемые паузы между предложениями
3. Сделать длительность пауз конфигурируемой (например, от 500мс до 3000мс)
4. Возможно добавить разные типы пауз: короткие внутри фразы, длинные между циклами

**Текущий SpeechService код для повторов:**
```typescript
startRepetition(phrase: string, intervalMs: number = 5000): void {
  // Очищаем только интервал повторов, не трогая речь
  this.clearRepetitionOnly();
  this.isRepetitionActive = true;
  
  if (!phrase) return;
  
  // Первый повтор
  this.speak(phrase, true);
  
  // Последующие повторы
  this.repetitionInterval = setInterval(() => {
    if (this.isRepetitionActive && !this.currentMainSpeech) {
      this.speak(phrase, true);
    }
  }, intervalMs);
}
```

## Дополнительные возможности для рассмотрения

1. **Настройка скорости речи** для разных типов контента (инструкции быстрее, повторы медленнее)
2. **Плавные переходы** между фразами в повторах
3. **Эмоциональная окраска** речи (разные тона для инструкций и медитативных фраз)
4. **Адаптивные паузы** в зависимости от длины предложений
5. **Дыхательные ритмы** - синхронизация пауз с дыхательными циклами

## Архитектурные файлы

**SpeechService** (`src/app/shared/services/speech.service.ts`) - 185 строк
**PracticeRunnerComponent** (`src/app/shared/components/practice-runner/practice-runner.component.ts`) - 380+ строк
**PracticeEngineV2Service** (`src/app/core/services/practice-engine-v2.service.ts`) - 200 строк

## Ожидаемый результат

1. **Исправление goBack()** - полноценная навигация назад по шагам
2. **Улучшенные повторы** - с настраиваемыми паузами между предложениями
3. **Возможные архитектурные улучшения** - если есть более элегантные решения

## Конкретные проблемы для решения

### Проблема 1: Неработающая кнопка "Назад"

**Текущее состояние:** Метод `goBack()` в `PracticeEngineV2Service` содержит заглушку:

```typescript
async goBack(): Promise<void> {
  if (this.stepHistory.length === 0) return;
  const lastStep = this.stepHistory.pop();
  // ПРОБЛЕМА: упрощенная реализация
  console.warn('GoBack is simplified - consider redesigning for full backward navigation');
}
```

**Сложность:** JavaScript generators можно только продвигать вперед. Для возврата назад нужно либо:
- Сохранять снимки состояний на каждом шаге
- Пересоздавать iterator с самого начала до нужного шага
- Использовать альтернативный подход (state machine, команды)

### Проблема 2: Настраиваемые паузы в повторяемых фразах

**Текущее состояние:** Фразы произносятся как непрерывный поток:
```
"Творец, исправь их намерение из получения в отдачу, приблизь их к себе и наполни их нехватки благом и наслаждением."
```

**Нужно:** Разбивать на предложения с паузами:
```
"Творец, исправь их намерение из получения в отдачу. [ПАУЗА 1с] Приблизь их к себе. [ПАУЗА 1с] Наполни их нехватки благом и наслаждением."
```

**Требования к парсеру пауз:**
- Распознавать конец предложений: `.` `!` `?`  
- Учитывать аббревиатуры: "и т.д.", "т.к."
- Настраиваемая длительность пауз (500мс - 3000мс)
- Разные паузы: короткие внутри фразы, длинные между циклами
- Сохранение плейсхолдеров: `{{userProblem}}`

## Вопросы для архитектурной рецензии

### 1. Оценка generator-based подхода
- Насколько хорошо generator функции подходят для определения практик?
- Есть ли более элегантные альтернативы для сложных практик с циклами?
- Правильно ли мы используем композицию через `yield*`?

### 2. Навигация назад в generator архитектуре
- Какой подход лучше для реализации `goBack()`?
- Стоит ли переходить на state machine или команды?
- Как сохранять/восстанавливать состояние iterator'а?

### 3. Парсинг фраз и управление паузами
- Где лучше реализовать парсер пауз - в SpeechService или отдельном классе?
- Как элегантно обрабатывать плейсхолдеры при разбивке на предложения?
- Стоит ли создать декларативный DSL для описания пауз?

### 4. Архитектурные улучшения
- Можно ли улучшить систему переиспользуемых блоков?
- Как лучше организовать конфигурацию практик?
- Есть ли паттерны для упрощения сложных практик с циклами?

### 5. Система речевого тренажера
- Правильно ли разделены обязанности между компонентами?
- Стоит ли выделить отдельный сервис для управления паузами?
- Как сделать систему максимально гибкой для будущих требований?